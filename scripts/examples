#!/usr/bin/env node
const globby = require('globby')

const chproc = require('child_process')
const fs     = require('fs')
const path   = require('path')
const {basename, dirname, relative, resolve} = path

const {gitFileStatus, mergePlain} = require('../src/util')
const {Logger} = require('..')

const EgScript = 'example.js'
const Readme = 'README.md'
const GitStatusOk = ['clean', 'added', 'staged']

const ExamplesDir = resolve(__dirname, '../examples')
const TemplateFile = resolve(__dirname, 'res/example-template.md')

class ExamplesScript {

    constructor(argv) {
        this.logger = new Logger
        this.isMain = require.main === module
        argv = argv || []
        this.task = argv[0] || 'help'
        const {opts, args} = this.parse(argv.slice(1))
        this.opts = opts
        this.args = args
    }

    run() {

        const {opts, logger} = this

        if (opts.silent) {
            logger.logLevel = 0
        } else if (opts.quiet) {
            logger.logLevel = 1
        }

        try {
            switch (this.task) {
                case 'run':
                    this.taskRun()
                    break
                case 'build':
                    this.taskBuild()
                    break
                case 'help':
                    this.taskHelp()
                    break
                default:
                    logger.error('Unknown task:', task)
                    this.taskHelp()
                    return this.exit(1)
                    break
            }
        } catch (err) {
            this.exit(err)
        }
    }

    taskHelp() {
        this.logger.info('Usage: node examples.js <task> [options]')
    }

    taskRun() {
        const {logger, opts, args} = this
        let examples = this.listNames(args)
        logger.info('Processing', examples.length, 'examples')
        const sopts = {}
        if (!opts.noout) {
            sopts.stdio = 'inherit'
        }
        examples.forEach(example => {
            logger.info('Running', {example})
            this.runExample(example, sopts)
        })
        logger.info('Done')
    }

    taskBuild() {

        const {logger, opts, args} = this
        const template = this.readTemplate()
        const examples = this.listNames(args)

        logger.info('Processing', examples.length, 'examples')

        if (opts.force) {
            logger.warn('Skipping git checks with --force option')
        } else {
            logger.info('Checking clean file status')
            this.checkGit(examples)
            logger.info('Git check passed')
        }

        const outputs = {}

        examples.forEach(example => {
            logger.info('Running', {example})
            const {stdout} = this.runExample(example)
            outputs[example] = stdout.toString('utf-8')
        })

        examples.forEach(example => {
            const file = resolve(ExamplesDir, example, Readme)
            const content = this.buildReadme(template, example, outputs[example])
            logger.info('Writing', relative(ExamplesDir, file))
            fs.writeFileSync(file, content)
        })

        logger.info('Done')
    }

    parse(raw) {
        raw = raw.slice(0)
        const checkOpt = (...strs) => {
            if (raw.some(it => strs.includes(it))) {
                raw = raw.filter(it => !strs.includes(it))
                return true
            }
            return false
        }
        const opts = {
            quiet: checkOpt('-q', '--quiet'),
            silent: checkOpt('-qq', '--silent'),
            noout: checkOpt('-n', '--noout'),
            force: checkOpt('-f', '--force'),
        }
        let args
        let idx = raw.indexOf('--')
        if (idx > -1) {
            args = raw.slice(idx + 1)
        } else {
            args = raw.filter(arg => arg[0] != '-')
        }
        return {opts, args}
    }

    exit(code = 0) {
        if (this.isMain) {
            if (code instanceof Error) {
                this.logger.error(code)
                code = 2
            }
            process.exit(code)
            return
        }
        if (code instanceof Error) {
            throw code
        }
        if (code !== 0) {
            throw new ScriptError(`examples.js script exit code ${code}`)
        }
    }

    listNames(names) {
        const examples = globby.sync(ExamplesDir + '/*/' + EgScript)
            .map(file => basename(dirname(file)))
        if (!names.length) {
            return examples
        }
        const invalid = names.filter(name => !examples.includes(name))
        if (invalid.length) {
            const estr = invalid.join(', ')
            throw new ScriptError(`Unknown example(s): ${estr}`)
        }
        return names
    }

    readTemplate() {
        return fs.readFileSync(TemplateFile, 'utf-8')
    }

    buildReadme(template, name, output) {
        const pre = output.split('\n').map(line => '    ' + line).join('\n')
        return template.replace('{name}', name).replace('{output}', pre)
    }

    checkGit(examples) {
        const {logger} = this
        let dirty
        try {
            dirty = examples.map(example => {
                const file = resolve(ExamplesDir, example, Readme)
                const {fileStatus} = gitFileStatus(file)
                return [relative(ExamplesDir, file), fileStatus]
            }).filter(([file, status]) =>
                !GitStatusOk.includes(status)
            )
        } catch (err) {
            if (err.stderr) {
                logger.warn('stderr:\n' + err.stderr)
            }
            throw err
        }
        if (dirty.length) {
            dirty.forEach(([file, status]) => {
                logger.error('Dirty path:', {file}, {status})
            })
            throw new ScriptError('Git check failed')
        }
    }

    runExample(name, sopts = {}) {
        const {logger} = this
        sopts = mergePlain(
            {
                // 10K max
                maxBuffer: 1024 * 10,
                env: {
                    ...process.env,
                    //FORCE_COLOR: '2',
                },
            },
            sopts,
        )
        const script = resolve(ExamplesDir, name, EgScript)
        const cmd = process.execPath
        const result = chproc.spawnSync(cmd, [script], sopts)
        if (result.error) {
            throw result.error
        }
        if (result.status != 0) {
            if (result.stderr) {
                logger.warn('stderr:\n' + result.stderr.toString('utf-8'))
            }
            throw new ScriptError(`Example exited with code ${result.status}`)
        }
        return result
    }
}


class ScriptError extends Error {
    constructor(...args) {
        super(...args)
        this.name = this.constructor.name
    }
}

if (require.main === module) {
    new ExamplesScript(process.argv.slice(2)).run()
}

module.exports = ExamplesScript